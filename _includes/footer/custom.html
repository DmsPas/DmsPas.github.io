<!-- start custom footer snippets -->
<a href="/sitemap/">Sitemap</a>
<!-- end custom footer snippets -->

<!-- Graph background animation -->
<canvas id="graph-bg"></canvas>
<style>
    #graph-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
        pointer-events: none;
        opacity: 0.18;
    }
</style>

<script>
    (function () {
        var canvas = document.getElementById('graph-bg');
        if (!canvas) return;
        var ctx = canvas.getContext('2d');
        var W = 0, H = 0;
        var nodes = [];
        var inited = false;

        // 8 clusters arranged in a circle (cx/cy are fractions of viewport W/H)
        // Radius 0.38h x 0.32v so it looks circular on widescreen
        var clusterColors = [
            '#e41a1c', // Red
            '#ff7f00', // Orange
            '#dbb000', // Yellow
            '#4daf4a', // Green
            '#00b4d8', // Cyan
            '#377eb8', // Blue
            '#984ea3', // Purple
            '#28282B'  // Near-black
        ];
        var NUM_CLUSTERS = 8;
        var clusterDefs = [];
        for (var k = 0; k < NUM_CLUSTERS; k++) {
            var angle = (k / NUM_CLUSTERS) * 2 * Math.PI;
            clusterDefs.push({
                cx: 0.5 + 0.38 * Math.cos(angle),
                cy: 0.5 + 0.32 * Math.sin(angle),
                color: clusterColors[k]
            });
        }

        var NUM_NODES = 400;   // Total number of nodes
        var MAX_DIST = 360;   // Maximum distance between nodes to draw an edge
        var CLUSTER_F = 0.001; // Strength of the force pulling nodes to their cluster centers
        var NOISE = 0.18;  // Random noise added to the velocity of each node
        var SPEED_CAP = 1.95;  // Maximum speed of any node

        function resize() {
            W = window.innerWidth || document.documentElement.clientWidth || 1200;
            H = window.innerHeight || document.documentElement.clientHeight || 800;
            canvas.width = W;
            canvas.height = H;
        }

        function initNodes() {
            nodes = [];
            var min_node_size = 10;
            for (var i = 0; i < NUM_NODES; i++) {
                var cl = clusterDefs[i % clusterDefs.length];
                nodes.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: (Math.random() - 0.5) * 0.6,
                    vy: (Math.random() - 0.5) * 0.6,
                    r: min_node_size + Math.random() * 2,
                    cluster: i % clusterDefs.length
                });
            }
        }

        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

        function step() {
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                var cl = clusterDefs[n.cluster];
                n.vx += CLUSTER_F * (cl.cx * W - n.x) + (Math.random() - 0.5) * NOISE;
                n.vy += CLUSTER_F * (cl.cy * H - n.y) + (Math.random() - 0.5) * NOISE;
                n.vx = clamp(n.vx, -SPEED_CAP, SPEED_CAP);
                n.vy = clamp(n.vy, -SPEED_CAP, SPEED_CAP);
                n.x += n.vx;
                n.y += n.vy;
                if (n.x < 0) { n.x = 0; n.vx *= -0.5; }
                if (n.x > W) { n.x = W; n.vx *= -0.5; }
                if (n.y < 0) { n.y = 0; n.vy *= -0.5; }
                if (n.y > H) { n.y = H; n.vy *= -0.5; }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);
            for (var i = 0; i < nodes.length; i++) {
                for (var j = i + 1; j < nodes.length; j++) {
                    var a = nodes[i], b = nodes[j];
                    var dx = a.x - b.x, dy = a.y - b.y;
                    var d = Math.sqrt(dx * dx + dy * dy);
                    if (d < MAX_DIST) {
                        ctx.strokeStyle = (a.cluster === b.cluster) ? clusterDefs[a.cluster].color : '#888';
                        ctx.globalAlpha = (1 - d / MAX_DIST) * 0.65;
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1;
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                ctx.beginPath();
                ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
                ctx.fillStyle = clusterDefs[n.cluster].color;
                ctx.fill();
            }
        }

        function loop() {
            if (!inited) {
                resize();
                if (W > 0 && H > 0) { initNodes(); inited = true; }
            }
            if (inited) { step(); draw(); }
            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', function () {
            resize();
            for (var i = 0; i < nodes.length; i++) {
                nodes[i].x = clamp(nodes[i].x, 0, W);
                nodes[i].y = clamp(nodes[i].y, 0, H);
            }
        });

        loop();
    })();
</script>